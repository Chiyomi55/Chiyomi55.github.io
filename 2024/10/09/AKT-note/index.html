<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>AKT-note | Memoryβ</title><meta name="author" content="Chiyomi"><meta name="copyright" content="Chiyomi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="论文标题：Context-Aware Attentive Knowledge Tracing 作者与发表日期： Ghosh, Aritra and Heffernan, Neil and Lan, Andrew S.  期刊或会议名称：KDD ‘20: The 26th ACM SIGKDD Conference on Knowledge Discovery and Data Mining Vi">
<meta property="og:type" content="article">
<meta property="og:title" content="AKT-note">
<meta property="og:url" content="http://example.com/2024/10/09/AKT-note/index.html">
<meta property="og:site_name" content="Memoryβ">
<meta property="og:description" content="论文标题：Context-Aware Attentive Knowledge Tracing 作者与发表日期： Ghosh, Aritra and Heffernan, Neil and Lan, Andrew S.  期刊或会议名称：KDD ‘20: The 26th ACM SIGKDD Conference on Knowledge Discovery and Data Mining Vi">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-10-09T06:59:28.000Z">
<meta property="article:modified_time" content="2024-10-11T03:27:33.335Z">
<meta property="article:author" content="Chiyomi">
<meta property="article:tag" content="readingnotes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/10/09/AKT-note/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'AKT-note',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-11 11:27:33'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Memoryβ</span></a><a class="nav-page-title" href="/"><span class="site-name">AKT-note</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">AKT-note</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-10-09T06:59:28.000Z" title="Created 2024-10-09 14:59:28">2024-10-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-10-11T03:27:33.335Z" title="Updated 2024-10-11 11:27:33">2024-10-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ul>
<li><strong>论文标题</strong>：Context-Aware Attentive Knowledge Tracing</li>
<li><strong>作者与发表日期</strong>： Ghosh, Aritra and Heffernan, Neil and Lan, Andrew S. </li>
<li><strong>期刊或会议名称</strong>：KDD ‘20: The 26th ACM SIGKDD Conference on Knowledge Discovery and Data Mining Virtual Event CA USA July 6 - 10, 2020 </li>
<li><strong>链接</strong>：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2007.12324">https://arxiv.org/abs/2007.12324</a></li>
<li><strong>DOI</strong>： 10.1145&#x2F;3394486.3403282 </li>
<li><strong>摘要：</strong> 知识追踪 （KT） 是指根据学习者过去在教育应用程序中的表现来预测未来学习者的表现的问题。使用基于灵活深度神经网络的模型的 KT 的最新发展在这项任务中表现出色。然而，这些模型的可解释性通常有限，因此不足以进行个性化学习，这需要使用可解释的反馈和可操作的建议来帮助学习者获得更好的学习成果。在本文中，我们提出了注意力知识追踪 （AKT），它将灵活的基于注意力的神经网络模型与一系列受认知和心理测量模型启发的新型、可解释的模型组件相结合。AKT 使用一种新颖的单调注意力机制，将学习者未来对评估问题的回答与他们过去的回答联系起来;除了问题之间的相似性外，注意力权重是使用指数衰减和上下文感知相对距离测量来计算的。此外，我们使用 Rasch 模型来正则化概念和问题嵌入;这些嵌入能够捕获关于同一概念的问题之间的个体差异，而无需使用过多的参数。我们在几个真实世界的基准数据集上进行了实验，结果表明 AKT 在预测未来学习者的反应方面优于现有的 KT 方法（在某些情况下，AUC 高达 6%）。我们还进行了几个案例研究，表明 AKT 表现出出色的可解释性，因此在现实世界的教育环境中具有自动反馈和个性化的潜力。</li>
</ul>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><img src="/2024/10/09/AKT-note/1728459097024.png"  alt="1728459097024" style="zoom:50%;" />

<p>ht代表t时刻的知识水平，rt代表t时刻对评估问题的回答评分（通常是二进制值，1代表回答正确，0则反）。因此前一个函数称为回答模型（response model），后一个称为知识进化模型（knowledge evolution model）。</p>
<p><strong>其他模型和方法：</strong></p>
<ul>
<li><strong>DKT：</strong>每个学习者对专家定义的概念的 Nowledge 级别。KT 的最新发展集中在：使用更复杂和灵活的模型来充分利用大规模学习者响应数据集中所包含的信息。深度知识追踪 （DKT） 方法是第一种通过使用长短期记忆 （LSTM） 网络作为知识进化模型 g（·） 来探索（可能是深度）神经网络用于 KT 的方法。由于 LSTM 单元是非线性的复杂函数，因此它们比仿射变换更灵活，并且更能够捕获真实数据中的细微差别</li>
<li><strong>DKVMN：</strong>动态键值记忆网络 （DKVMN） 方法通过使用外部记忆矩阵 （Ht） 来表征学习者知识 。该矩阵分为两部分：一个静态的“关键”矩阵，其中包含每个概念的固定表示，以及一个动态的“价值”矩阵，其中包含每个学习者对每个概念的不断发展的知识水平。DKVMN 还在这个外部矩阵上为响应和知识进化模型使用单独的 “read” 和 “write” 过程;这些过程使其比 DKT 更灵活。DKT 和 KVMN 报告了预测未来学习者表现的最新性能 ，并已成为新 KT 方法的基准。</li>
<li><strong>SAKT：</strong>自我关注知识追踪（SAKT）方法是在KT环境中使用注意力机制的第一种方法。注意力机制比递归和基于记忆的神经网络更灵活，并且在自然语言处理任务中表现出卓越的性能。SAKT 的基本设置与 Transformer 模型 有许多相似之处，Transformer 模型是许多序列到序列预测任务的有效模型。然而，我们观察到 SAKT 在我们的实验中并没有优于 DKT 和 DKVMN 。可能的原因包括：<br>   <strong>i）</strong> <strong>与单词之间常常具有强烈长距离依赖性的语言任务不同，未来学习者表现对过去的依赖性可能仅限于更短的窗口</strong>；<br>   <strong>ii） 学习者响应数据集的大小比自然语言数据集小几个数量级，并且不太可能从高度灵活和大规模的注意力模型中受益。</strong></li>
</ul>
<p>更重要的是，没有现有的 KT 方法真正擅长<strong>未来性能预测</strong>和<strong>可解释性</strong>。早期的 KT 方法表现出出色的可解释性，但在预测未来学习者的表现方面没有提供最先进的性能。最近基于深度学习的 KT 方法在这方面表现出色，但提供的可解释性有限。<strong>因此，</strong>这些知识转移方法并不能完全满足个性化学习的需求，这不仅需要准确的表现预测，还需要提供自动化、可解释的反馈和可操作的建议的能力，以帮助学习者获得更好的学习成果。</p>
<h1 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h1><p><em>为了预测学习者对当前问题的回答，我们提出了注意力知识追踪 （AKT） 方法，该方法使用一系列注意力网络在这个问题和学习者过去回答的每个问题之间建立联系。我们总结了以下主要创新：</em></p>
<ul>
<li>与使用原始问题和响应嵌入的现有注意力方法相反，我们<strong>将原始嵌入放入上下文中</strong>，并通过考虑学习者的整个实践历史，<strong>使用过去问题和响应的上下文感知表示</strong>。</li>
<li>受认知科学关于遗忘机制的发现的启发，我们提出了一种<strong>新的单调注意力机制</strong>，它使用<strong>指数衰减曲线</strong>来降低遥远过去问题的重要性。我们还开发了一个上<strong>下文感知度量</strong>来描述学习者过去回答的问题之间的时间间隔。</li>
<li>利用 <strong>Rasch 模型</strong>，一种简单且可解释的 IRT 模型，我们使用一系列基于 Rasch 模型的嵌入来捕捉问题之间的个体差异，而无需引入过多的模型参数。</li>
</ul>
<p><em>我们在几个基准真实世界的教育数据集上进行了一系列实验，将 AKT 与最先进的 KT 方法进行比较。我们的结果表明，AKT（有时显着）在预测未来学习者的表现方面优于其他 KT 方法。此外，我们对每个关键的 AKT 模型组件进行了消融研究，以证明它们的价值。我们还进行了几个案例研究，以表明 AKT 表现出<strong>出色的可解释性</strong>，并且具有<strong>自动反馈和练习题推荐的潜力</strong>，这两者都是个性化学习的关键要求。</em></p>
<hr>
<h1 id="Problem-Setup"><a href="#Problem-Setup" class="headerlink" title="Problem Setup"></a>Problem Setup</h1><p>每个学习者的表现记录都包含每个离散时间步长的一系列问题和回答。对于时间步 t 的学习者 i，我们表示他们回答的问题、这个问题涵盖的概念以及他们以元组形式给出的分级响应的组合<em><strong>（qit ， cti ， rti ）</strong></em>，其中 qit ∈ N+ 是<strong>问题索引</strong>，cti ∈ N+ 是<strong>概念索引</strong>，rti ∈ {0， 1} 是回答。在此表示法下，（qit ， cti ， 1） 表示学习者 i 在时间 t 正确回答了概念 cti 上的问题 qit。此设置与之前的一些深度知识跟踪工作不同，这些工作经常忽略问题索引并将学习者的表现总结为 （cti ， rti ）。做出这个选择是为了避免过度参数化；在以下讨论中，我们省略了上标 i，因为我们讨论了如何预测<strong>单个学习者</strong>的未来表现。鉴于他们过去到时间 t − 1 的历史为 {（q1， c1， r1）， . . ， （qt −1， ct −1， rt −1）}，我们的目标是预测他们在当前时间步 t 对概念 ct 上的问题 qt 的回答 rt。</p>
<hr>
<p><strong>问题和回答的嵌入表达</strong></p>
<p>我们使用实值嵌入向量xt ∈ RD和yt ∈ RD来分别表示<strong>每个问题</strong>和<strong>每个问题-响应对</strong>（qt、rt）。</p>
<ul>
<li><strong>xt</strong> 描述<strong>有关问题的信息</strong> ;</li>
<li>而 <strong>yt</strong> 描述<strong>学习者通过回答问题获得的知识</strong>，分别使用<strong>两个单独的嵌入来表示正确和错误的回答</strong>。</li>
</ul>
<p>D 表示这些嵌入的维度。因此，让 Q 表示问题的数量，总共有 Q 个问题嵌入向量和 2Q 个问题-响应嵌入向量。在大多数现实世界的教育环境中，题库比概念集大得多，并且许多问题被分配给极少数学习者。因此，大多数现有的 KT 方法都<strong>使用概念来索引问题以避免过度参数化</strong> ; <em>涵盖同一概念的所有问题都被视为单个问题</em>。在这种情况下，qt &#x3D; ct 即Q &#x3D; C。</p>
<hr>
<h1 id="THE-AKT-METHOD"><a href="#THE-AKT-METHOD" class="headerlink" title="THE AKT METHOD"></a>THE AKT METHOD</h1><p><strong>AKT 方法由四个部分组成：</strong></p>
<p>1）两个自注意<strong>编码器</strong>，一个用于问题，一个用于知识获取，</p>
<p>2）一个基于注意力的<strong>知识检索器</strong></p>
<p>3）一个<strong>前馈响应预测模型</strong></p>
<p>下图直观地显示了 AKT 方法及其连接组件。</p>
<img src="/2024/10/09/AKT-note/1728463295714.png" class="" width="1728463295714">

<blockquote>
<p><em>图 1：AKT 方法概述。我们使用基于 Rasch 模型的嵌入作为问题和响应的原始嵌入。问题和知识编码器计算问题和响应对的上下文感知表示形式。知识检索器使用这些表示形式作为输入，并计算学习者的知识状态。为简单起见，我们不在编码器中展示单调注意力机制。我们也不显示子图层。</em></p>
</blockquote>
<p>我们使用两个自我关注编码器来学习问题和回答的上下文感知表示。我们将第一个编码器称为<strong>问题编码器</strong>，它会根据学习者之前练习过的问题序列，为<strong>每个问题</strong>生成经过改良的、情境化的表示。同样，我们将第二个编码器称为<strong>知识编码器</strong>，它生成学习者在回答过去问题时<strong>获得的知识</strong>的改良后的、情境化表示。或者，我们可以使用类似于之前工作的问题和响应的原始嵌入。我们发现，<strong>上下文感知表示</strong>在大多数数据集中表现更好。我们将<strong>知识进化模型</strong>称为<strong>知识检索器</strong>，它使用注意力机制检索过去获得的<strong>与当前问题相关的知识。</strong>最后，<strong>响应预测模型</strong>使用检索到的知识<strong>预测</strong>学习者对当前问题的响应。</p>
<blockquote>
<p><em>AKT 方法的动机是植根于认知科学和心理测量学的三种直觉。</em></p>
</blockquote>
<hr>
<h2 id="上下文感知表达和知识检索器"><a href="#上下文感知表达和知识检索器" class="headerlink" title="上下文感知表达和知识检索器"></a>上下文感知表达和知识检索器</h2><p>我们在模型中使用了两个编码器。问题编码器将<strong>原始问题嵌入</strong> {x1， . . . ， xt } 作为输入，并使用单调注意力机制输出一系列<strong>上下文感知问题嵌入</strong> {xˆ1， . . .， ˆxt }。每个问题的上下文感知嵌入<em><strong>取决于自身和过去</strong></em>的问题，即 ˆxt &#x3D; fenc1 （x1， . . . ， xt ）。</p>
<img src="/2024/10/09/AKT-note/1728469204291.png"  alt="1728469204291" style="zoom:67%;" />

<p>同样，知识编码器将<strong>原始问题-响应嵌入</strong> {y1， . . . ， yt−1} 作为输入，并使用相同的单调注意力机制输出获得的<strong>实际知识序列</strong> {yˆ1， . . . ， yˆt−1}。所获知识的语境感知嵌入<em><strong>取决于学习者对当前问题和过去问题的回答</strong></em>，即 yˆt−1 &#x3D; fenc2 （y1， . . . ， yt −1）。</p>
<img src="/2024/10/09/AKT-note/1728469216072.png"  alt="1728469216072" style="zoom:67%;" />

<blockquote>
<p><em>选择使用上下文感知嵌入而不是原始嵌入反映了我们的第一种直觉：学习者在回答问题时理解和学习的方式取决于学习者。这些修改后的表示反映了每个学习者对问题的实际理解以及他们根据个人回答历史实际获得的知识。这种模型选择的动机是出于直觉，即对于过去反应序列不同的两个学习者，他们理解同一问题的方式和他们从练习中获得的知识可能会有所不同。</em></p>
</blockquote>
<p>知识检索器将<strong>上下文感知</strong>问题<strong>和问题-响应对嵌入</strong> ˆx1：t 和 yˆ1：t −1 作为输入，并输出针对当前问题的检索到的<strong>知识状态 ht</strong>。我们注意到，在 AKT 中，学习者的当前知识状态<strong>也是上下文感知</strong>的，因为它取决于他们正在回答的当前问题 。知识检索器只能使用有关过去问题的信息、学习者对这些问题的回答以及当前问题的表示形式，而不能使用学习者对当前问题的回答，即 ht &#x3D; fkr（ˆx1， . . . ，xˆt ， yˆ1， . . . ，yˆt−1）。响应预测模型使用检索到的知识来预测当前响应。</p>
<hr>
<h2 id="单调注意力机制"><a href="#单调注意力机制" class="headerlink" title="单调注意力机制"></a>单调注意力机制</h2><p>我们对编码器和知识检索器使用<strong>缩放点积注意力机制修改后的单调版本</strong>。我们首先简要总结一下最初的缩放点积注意力机制：在此框架下，每个编码器和知识检索器都有一个<strong>键</strong>、<strong>查询</strong>和<strong>值嵌入层</strong>，该层将输入分别映射到维度 Dq &#x3D; Dk 、 Dk 和 Dv 的输出查询、键和值。设 <strong>qt</strong> ∈ RDk ×1 表示与学习者在<strong>时间 t 回答的问题</strong>相对应的查询，<strong>缩放的点积注意力值</strong> <strong>αt，τ</strong> 使用 softmax 函数计算为</p>
<img src="/2024/10/09/AKT-note/1728470728912.png"  alt="1728470728912" style="zoom:67%;" />

<p>两个<strong>编码器都采用自注意力机制</strong>，即 qt 、 kt 和 vt（查询、键、值） 是使用<strong>相同的输入</strong>计算的  ; 问题编码器使用 {x1， . . . ， xt }，而知识编码器使用 {y1， . . . ， yt−1}。</p>
<p>另一方面，<strong>知识检索器不使用自我注意</strong>。在时间步 t 处，它使用：</p>
<ol>
<li>ˆxt<strong>（当前问题的修改嵌入）</strong>、{ ˆx1， . . . ， ˆxt−1}（<strong>过去问题的上下文感知嵌入）</strong></li>
<li>{yˆ1， . . . ， yˆt−1}（<strong>过去问题-响应对的上下文感知嵌入）</strong>作为输入</li>
</ol>
<p>来分别生成查询、键和值。我们注意到，SAKT 使用问题嵌入向量来映射查询，而使用响应嵌入向量来映射键和值。在我们的实验中，我们发现使用问题嵌入来映射查询和键要有效得多。</p>
<hr>
<p>然而，这种基本的缩放点积注意力机制对 KT 来说可能还不够。原因是学习是暂时的，记忆会衰减 ; 当我们预测学习者对当前问题的回答时，学习者在遥远过去的表现<strong>不如</strong>最近的表现提供信息。因此，我们开发了<strong>一种新的单调注意力机制</strong>来反映我们的第二直觉：当学习者面临一个新问题时，<strong>过去在不相关概念上的经验</strong> 和 <strong>太久以前的经验</strong>不太可能高度相关。具体来说，我们在注意力分数中添加一个<em><strong>乘法指数衰减项</strong></em>，如下所示：</p>
<img src="/2024/10/09/AKT-note/1728477973655.png"  alt="1728477973655" style="zoom:67%;" />

<p>以及：</p>
<img src="/2024/10/09/AKT-note/1728547248044.png"  alt="1728547248044" style="zoom:67%;" />

<p>其中 θ &gt; 0 是可学习的<strong>衰减率参数</strong>，<strong>d（t，τ ）</strong>是时间步长 t 和 τ 之间的<strong>时间距离测量</strong>。换句话说，当前问题对过去问题的<strong>关注权重不仅取决于对应 query 和 key 之间的相似度</strong>，<strong>还取决于它们之间的相对时间步长数</strong>。总之，我们的单调注意力机制采用随时间呈指数衰减曲线的基本形式，当过去的问题与当前问题高度相似时，时间步长可能会出现峰值。注意，我们将指数衰减应用于注意力权重而不是潜在知识，这是现有学习者模型中的常见方法。</p>
<hr>
<h3 id="上下文感知距离度量"><a href="#上下文感知距离度量" class="headerlink" title="上下文感知距离度量"></a>上下文感知距离度量</h3><p>指数衰减函数决定了注意力权重随着当前时间索引与先前时间索引之间距离的增加而衰减的速率。定义两个时间索引之间距离的<strong>一种直接方法是它们的绝对值差</strong>。但是，此距离不是上下文感知的，并且会忽略每个学习者的练习历史记录。</p>
<blockquote>
<p>例如，考虑学习者练习的以下两个概念序列：PN1、VD2、VD3、···、VD9、PN10<br>其中，PN和VD分别代表有素数概念和韦恩图概念的练习题。<br>即，符号“VD2”表示学习者在时间步 2 时刻练习了维恩图的概念。</p>
<p>在此示例中，学习者回答了关于 t &#x3D; 10 处的质数（即当前时间索引）的问题，但过去关于质数的最新做法是不同的时间索引。由于维恩图和素数的概念并不密切相关，因此在预测学习者对当前练习题的回答时，学习者以前对素数的练习比最近对维恩图的练习更与我们相关。</p>
</blockquote>
<p><strong>在这种情况下，由于绝对值差值简单明了，指数衰减曲线将显著降低在 t &#x3D; 1 时分配给素数练习的注意力权重。</strong>因此，我们提出了以下时间步长 d（t， τ ） 之间的<strong>上下文感知距离测量</strong>，τ ≤ t，用于指数衰减机制（在编码器中）：</p>
<img src="/2024/10/09/AKT-note/1728548780487.png"  alt="1728548780487" style="zoom:67%;" />

<p>对于知识检索器，我们将 τ ′ ≤ t 替换为 τ &lt; t，将 t ′ ≤ t 替换为 t ′ &lt; t。换句话说，这种<strong>上下文感知距离测量使用另一个 softmax 函数</strong>，根据过去实践的概念与当前概念的关系来<strong>调整连续时间索引之间的距离（？）</strong>。在实践中，在模型训练期间的每次迭代中，我们使用当前的 AKT 模型参数来计算修改后的距离度量并对其进行修复 ; 我们不会通过 Distance 度量传递梯度。</p>
<hr>
<h3 id="多头注意力和子图层"><a href="#多头注意力和子图层" class="headerlink" title="多头注意力和子图层"></a>多头注意力和子图层</h3><p>本文方法还纳入了<strong>多头注意力</strong>，在多个时间尺度上有效地<strong>关注过去的位置</strong> 。因此使用了 H 个独立的注意力头，其中每个头都有自己的衰减率 θ ，将最终输出连接成一个 （Dv ·H ） × 1 向量并将其传递给下一层。这种模型设计使 AKT <strong>能够在多个时间尺度上总结过去的学习者表现</strong>，这与多尺度上下文、DASH 和 DAS3H 模型中的多个时间窗口有一些相似之处 。</p>
<p>我们还<strong>使用了几个子层</strong>，包括一个用于<strong>层归一化</strong> ，一个用于 <strong>dropout</strong> ，一个<strong>全连接前馈层</strong>，以及<strong>每个编码器和知识检索器中的残差连接层</strong> 。</p>
<hr>
<h2 id="响应预测"><a href="#响应预测" class="headerlink" title="响应预测"></a>响应预测</h2><p>AKT 方法的最后一个组件：预测学习者对当前问题的回答。预测模型的<strong>输入是一个向量</strong>，它连接<strong>检索到的知识（知识检索器输出 ht ）</strong>和<strong>当前问题嵌入 xt</strong> 。此输入通过另一个<strong>全连接网络</strong>，最后通过 <strong>sigmoid 函数</strong>生成学习者正确回答当前问题的<strong>预测概率</strong> rˆt ∈ [0， 1]。整个 AKT 方法中的所有可学习参数都以端到端方式进行训练，方法是最大限度地<strong>减少所有学习器响应的二进制交叉熵损失</strong>，即</p>
<img src="/2024/10/09/AKT-note/1728550795993.png"  alt="1728550795993" style="zoom:67%;" />

<h2 id="基于Rasch模型的嵌入"><a href="#基于Rasch模型的嵌入" class="headerlink" title="基于Rasch模型的嵌入"></a>基于Rasch模型的嵌入</h2><p>正如我们上面所讨论的，现有的 KT 方法<strong>使用概念来索引问题</strong>，即设置 qt &#x3D; ct 。由于数据稀疏性，此设置是必要的。让 Q 表示问题总数，L 表示学习者的数量。在大多数实际学习者响应数据集中，学习者响应的数量与 CL 相当，但比 QL 少得多，因为许多问题被分配给少数学习者。因此，<strong>使用概念为问题编制索引可以有效避免过度参数化和过度拟合</strong>。然而，这种基本设置<strong>忽略了</strong>涵盖同一概念的问题之间的<strong>个体差异</strong>，<em><strong>从而限制了 KT 方法的灵活性及其个性化的潜力 。</strong></em></p>
<p>我们使用心理测量学中一个经典而强大的模型，即 Rasch 模型（也称为 1PL IRT 模型）来构建原始问题和知识嵌入。Rasch 模型使用<strong>两个标量来描述学习者正确回答问题的概率：问题的难度和学习者的能力</strong>。尽管它很简单，但事实证明，当知识是静态的时候，它在正式评估中可以实现与更复杂的学习者表现预测模型相当的性能。具体来说，我们从位于时间步t的概念ct来说：</p>
<img src="/2024/10/09/AKT-note/1728553115252.png"  alt="1728553115252" style="zoom: 67%;" />

<p>其中 cct ∈ RD 是此<strong>问题涵盖的概念的嵌入</strong>，dct ∈ RD 是<strong>总结涵盖此概念的问题们的变化的向量</strong>，μqt ∈ R 是一个<strong>标量难度参数</strong>，控制<strong>此问题偏离其涵盖的概念的程度</strong>。概念 ct 中的问题-响应对 （qt ， rt ） <strong>使用每对的标量难度参数</strong>以类似方式<strong>扩展</strong>：</p>
<img src="/2024/10/09/AKT-note/1728553412964.png"  alt="1728553412964" style="zoom:67%;" />

<p>其中 e（ct，rt ） ∈ RD 是<strong>概念-响应嵌入</strong>， 和f（ct，rt ） ∈ RD是<strong>变化向量</strong>。这个模型的选择反映了我们的第三个直觉：<strong>标记为涵盖相同概念的问题密切相关，但具有不应忽视的重要个体差异。</strong>这种模型选择部分受到了另一项融合 KT 和 IRT 模型的工作的启发 [8]</p>
<blockquote>
<p> <em>[8] MM Khajah, Y Huang, JP González-Brenes, MC Mozer, and P  Brusilovsky. 2014. Integrating knowledge tracing and item response  theory: A tale of two frameworks. In Proc. International Workshop on  Personalization Approaches in Learning Environments, Vol. 1181. 7–15.</em> </p>
</blockquote>
<p>这些基于 Rasch 模型的嵌入在<strong>建模个体问题差异</strong>和<strong>避免过度参数化</strong>之间<strong>取得了适当的平衡</strong>。我们注意到， question 和 question-response embeddings 共享一组参数 （cct ）; 此设置与现有的基于神经网络的 KT 方法不同，在这两种方法中，两者彼此独立。这些紧凑的嵌入表示不仅显着减少了 AKT 中的参数数量，还减少了其他一些 KT 方法中的参数数量，从而提高了未来学习者性能预测的性能 ; 有关详细信息，请参见表 5。</p>
<img src="/2024/10/09/AKT-note/1728553645535.png" class="" width="1728553645535">

<hr>
<h1 id="Experimental-Results"><a href="#Experimental-Results" class="headerlink" title="Experimental Results"></a>Experimental Results</h1><img src="/2024/10/09/AKT-note/1728565898000.png"  alt="1728565898000" style="zoom:67%;" />

<p>在所有这些数据集上，我们遵循文献中的一系列标准预处理步骤。对于 ASSISTments2009 数据集，我们删除了所有未与命名概念关联的交互。对于 ASSISTments2015 数据集，我们删除了 “isCorrect” 字段不是 0 或 1 的所有交互。我们在表 1 中列出了学习者、概念、问题和 questionresponse 对的数量。在这些数据集中，只有 ASSISTments2009 和 ASSISTments2017 数据集包含问题 ID ; 因此，基于 Rasch 模型的嵌入<strong>仅适用于这两个数据集。</strong></p>
<hr>
<p><strong>基线方法和评估指标</strong></p>
<p>我们将AKT与几种基线KT方法进行了比较，包括BKT+、DKT、DKT+（这是DKT的改进版本，对预测一致性进行了正则化）、DKVMN 和最近提出的SAKT方法，该方法使用一种注意力机制，可以看作是AKT的一个特殊情况，没有问题和回答的上下文感知表示以及单调的注意力机制。我们使用受试者工作特征曲线下面积 （AUC） 作为指标来评估所有 KT 方法在预测二进制值未来学习者对问题的反应方面的性能。</p>
<img src="/2024/10/09/AKT-note/1728566772765.png" class="" width="1728566772765">

<p><strong>训练和测试</strong></p>
<p>出于评估目的，我们对所有模型和所有数据集执行标准的 <strong>k 折交叉验证</strong>（k &#x3D; 5）。因此，对于每个折叠，20% 的学习者用作测试集，20% 的学习者用作验证集，60% 的学习者用作训练集。对于每个折叠，我们使用验证集来执行<strong>早期停止</strong>并调整每种 KT 方法的参数。出于计算效率的原因，我们按照<strong>截断</strong>了长度超过 200 的学习器响应序列。如果学习者的响应超过 200 个，我们会将其整个序列<strong>分解</strong>为多个较短的序列。我们使用 <strong>Adam 优化器</strong>来训练所有模型，批处理大小为 24 个学习者，以确保整个批处理可以放入我们机器的内存（配备一个 NVIDIA Titan X GPU）。我们在 PyTorch 中实现所有版本的 AKT ; 我们还重新实现了 DKT、DKT+ 和 SAKT，因为包含问题 ID 需要新的数据集分区并导致新的实验结果。</p>
<img src="/2024/10/09/AKT-note/1728609142046.png" class="" width="1728609142046">

<p>表 2 列出了所有数据集中所有 KT 方法在预测未来学习者反应方面的性能;我们报告了 5 个测试折叠的平均值和标准差。AKT-R 和 AKT-NR 分别表示<strong>具有和没有基于 Rasch 模型的嵌入</strong>的 AKT 模型的变体。我们看到 AKT（有时显着）在 ASSISTments 数据集上优于其他 KT 方法，而 DKT+ 在最小的 Statics2011 数据集上略优于 AKT。<em><strong>通常，AKT 在较大的数据集上表现更好;这一结果表明，注意力机制比递归神经网络更灵活，因此更能够捕获大规模真实世界学习者反应数据集中包含的丰富信息。</strong></em>在 ASSISTments2015 和 ASSISTments2017 数据集上，AKT-NR 将 AUC 分别比最接近的基线提高了 6% 和 1%。它的性能与 Statics2011 和 ASSISTments2009 数据集上性能最佳的基线相当。<em><strong>更重要的是，在带有问题 ID 的 ASSISTments2009 和 2017 数据集上，AKT-R 的性能明显优于其他 KT 方法</strong></em>，分别比最接近的基线高出 2% 和 6%。我们注意到，在我们的实现中，DKT 优于更高级的 DKVMN 方法。</p>
<blockquote>
<p>在带有问题 ID 的 ASSISTments2009 和 2017 数据集上，AKT-R 的性能明显优于其他知识追踪（KT）方法，主要原因与<strong>基于 Rasch 模型的嵌入</strong>和<strong>问题 ID 的使用</strong>相结合有关：</p>
<ol>
<li><strong>Rasch 模型的嵌入</strong>：Rasch 模型是一种测量模型，广泛应用于教育领域，主要用于测量问题的难度和学生的能力。通过将 Rasch 模型的嵌入加入到 AKT 中，模型可以更好地估计不同问题的难度以及学生的能力差异，这种精细的刻画提升了模型对学习者反应的预测能力。问题 ID 提供了特定问题的详细信息，而 Rasch 模型的嵌入能根据这些 ID 更精确地调整预测，从而提升了性能。</li>
<li><strong>问题 ID 的额外信息</strong>：带有问题 ID 的数据集可以提供比仅仅是知识点（如“数学中的代数”）更具体的细节。问题 ID 指定了特定的题目，这让模型能够区分出同一知识点下不同题目的差异性。而基于问题 ID 的 Rasch 嵌入可以帮助模型更好地理解每个具体问题的特征和学习者的应对情况，从而增强模型的细粒度预测能力。</li>
<li><strong>灵活的注意力机制</strong>：AKT 使用了注意力机制，能够在不同学习步骤间选择性地关注重要的信息。在带有问题 ID 的数据集上，注意力机制可以更灵活地捕捉每个问题的特征，特别是结合 Rasch 嵌入后，模型能够专注于难度差异显著的问题以及与学习者能力匹配的题目，从而提供更好的预测。</li>
</ol>
</blockquote>
<hr>
<p><strong>消融研究</strong></p>
<p>为了证明 AKT 方法中三个创新点的合理性：</p>
<ul>
<li>问题和回答的<strong>上下文感知表示</strong></li>
<li><strong>单调注意力机制</strong></li>
<li><strong>基于 Rasch 模型的嵌入</strong>（ 将难度和能力的概念引入到特征空间中 ）</li>
</ul>
<p><strong>第一个实验</strong>将 AKT-NR 和 AKT-R 与两种变体 AKTraw-NR 和 AKTraw-R 使用上下文感知问题和响应表示（带有问题和知识编码器）进行了比较;在这些变体中，我们使用原始的问题和响应嵌入作为它们的表示形式，而不是上下文感知的表示形式（即，不通过编码器传递它们）。</p>
<img src="/2024/10/09/AKT-note/1728567535108.png"  alt="1728567535108" style="zoom: 80%;" />

<blockquote>
<p><em>表 3：AKT 优于不使用<strong>上下文感知问题和响应表示</strong>的变体。</em></p>
</blockquote>
<p>表 3 显示了上下文感知表示（即问题和知识编码器）的第一次消融实验的结果（由于空间限制，只有测试折叠之间的平均值，而不是标准差）。在所有数据集上，AKT-R 和 AKTNR 的性能都优于它们的对应数据集 AKTraw-NR 和 AKTraw-R，它们只使用具有指数衰减的单一自我注意机制（即知识检索器）。这些结果表明，我们对问题和回答的上下文感知表示可以有效地总结每个学习者的实践历史。</p>
<hr>
<p><strong>第二个实验</strong>将 AKT-NR 与没有单调注意力机制的几种变体进行了比较。这些变体包括 AKT-NRpos，它使用（可学习的）位置编码来捕获学习者响应数据中的时间依赖性，以及 AKT-NRfixed，它使用（固定）位置编码，使用不同频率的正弦和余弦函数 [29]。</p>
<img src="/2024/10/09/AKT-note/1728567544024.png"  alt="1728567544024" style="zoom:80%;" />

<blockquote>
<p><em>表 4：AKT 明显优于其不使用<strong>单调注意力</strong>的变体。</em></p>
</blockquote>
<p>表 4 显示了单调注意力机制的第二次消融实验的结果。我们看到，在所有数据集上，AKT-NR 明显优于其他使用位置嵌入的注意力机制，包括 SAKT，大约是 1% 到 6%。我们假设造成这一结果的原因是：与单词之间强烈的长距离依赖性更常见的语言任务不同，<strong>未来学习者的表现对过去的依赖性仅限于更短的时间窗口。</strong>因此，在注意力权重中使用具有<strong>不同指数衰减率的多头注意力</strong>可以有效地捕捉不同时间尺度上对过去的短期依赖性。</p>
<hr>
<p><strong>第三个实验</strong>在有问题 ID 可用的 ASSISTments2009 和 2017 数据集上将 AKT-R 与 AKT-NR、DKT、DKT-R、DKT+、DKT+-R、DKVMN、DKVMN-R、SAKT 和 SAKT-R 进行了比较;DKT-R、DKT+-R、DKVMN-R 和 SAKT-R 分别是指使用基于 Rasch 模型的嵌入作为输入增强的 DKT、DKT+、DKVMN 和 SAKT 方法。</p>
<img src="/2024/10/09/AKT-note/1728613687516.png" class="" width="1728613687516">

<blockquote>
<p><em>表 5：基于 Rasch 模型的嵌入（有时显着）提高了 KT 方法的性能。</em></p>
</blockquote>
<p>表 5 显示了在两个 ASSISTments 数据集上基于 Rasch 模型的嵌入的第三次消融实验的结果，其中问题 ID 可用。所有添加了基于 Rasch 模型的嵌入的基线 KT 方法均优于其常规版本，尤其是在 ASSISTments2017 数据集上。这些结果<strong>证实了我们的直觉，即将涵盖同一概念的所有问题视为单个问题是有问题的 ; 只要可以避免过度参数化，这些问题之间的个体差异就不应该被忽视。</strong></p>
<p><strong>【备注】</strong> <em>在实验设置中，对于标记了多个概念的问题，单个学习者回答将重复多次，每个概念重复一次。其他作品对这些问题使用了不同的实验设置 ; 在 [31] 中，作者删除了这些问题，结果，DKT 的性能下降到 0.71。在 [33] 中，作者为同时出现的单个概念的每个组合构建了新概念，结果，DKT 的性能下降到 0.73。因此，我们还在 ASSISTments2009 数据集上使用了另一种实验设置。对于标记了多个概念的问题，我们会对相应的概念嵌入进行平均，并将其用作输入嵌入和响应预测。表 6 列出了此设置下所有 KT 方法在 ASSISTments2009 数据集上的性能。使用平均嵌入时，DKT 的性能下降到 0.76，比 [31， 33] 下的设置要好。与所有 KT 方法的标准实验设置相比，我们观察到类似的性能下降，而 AKT-R 仍然轻松优于所有基线。（这部分有点没懂）</em></p>
<hr>
<img src="/2024/10/09/AKT-note/1728615445700.png"  alt="1728615445700" style="zoom:67%;" />

<blockquote>
<p>图（a）是AKT 解码器中三个注意力头的 <strong>注意力权重的可视化</strong></p>
<p>图（b）是学习者三个连续<strong>练习题的注意力权重</strong>（以T为最临近的）</p>
</blockquote>
<p>图可反映出来：<strong>概念相似度</strong>和<strong>新近度</strong>是控制注意力权重的关键因素。</p>
<p><strong>图的详细解释：</strong>图（b）可视化了单个学习者在三个连续时间步长中的知识检索器中的标准化注意力权重。在最上面一行中，学习者在从 T − 10 到 T − 5 练习概念 T 后，在时间 T 回答概念 30 的问题，然后休息后继续练习概念 42，然后在时间 T − 1 回到概念 30。我们看到，AKT 通过<strong>更多地关注关于这个概念的先前实践（包括不久的过去和更远的过去）而不是不久前的另一个概念的实践来预测他们对当前问题的回答</strong>。在中间一行，学习者再次切换到 Concept 42 练习。同样，AKT 学会了关注同一概念的过去实践，而不是在时间 T − 2 和 T − 1 的不同概念上关注不久的过去。在最下面一行中，学习者连续第二次练习概念 42，AKT 显示出与最上面行类似的焦点模式，概念 30 和 42 的角色互换了。这些观察结果表明，AKT 的单调注意力机制有可能通过将学习者当前的反应与他们过去的反应联系起来来向教师提供反馈 ; 这些信息可能使教师<strong>能够选择他们已经练习过的某些问题，以便他们在继续之前重新练习并消除误解</strong>。我们还注意到，AKT 使用<strong>数据驱动</strong>的方法，学习这些与现有 KT 方法中的手工制作特征相匹配的注意力模式（例如，对这个概念的总尝试次数和正确尝试次数）  <em>（有这么厉害吗）</em></p>
<img src="/2024/10/09/AKT-note/1728616368516.png" class="" width="1728616368516">

<blockquote>
<p><em>图 3：学习到的<strong>问题嵌入的可视化</strong>，以及学习者对所选概念的正确回答比例。</em></p>
</blockquote>
<p><strong>Rasch 基于模型的嵌入</strong></p>
<p>图 3 使用 ASSISTments2009 数据集使用 t-SNE [28] 可视化了几个概念的基于 Rasch 模型的学习问题嵌入，以及它们对选定问题（学习者正确回答的部分）的经验困难。我们还基于它们的实证困难突出了每个概念的最难的和最简单的问题。我们看到，<strong>关于同一概念的问题形成一条曲线，并按其难度级别排序</strong>：对于大多数概念，线段一端的问题是简单的，而另一端的问题是困难的。这个结果证实了我们的直觉，<strong>即来自同一概念的问题并不相同，而是彼此密切相关 ; Rasch 模型可以使用其 difficulty 参数很好地捕捉到这种关系。</strong></p>
<hr>
<img src="/2024/10/09/AKT-note/1728616694020.png"  alt="1728616694020" style="zoom:67%;" />

<blockquote>
<p><em>表 7：关于三个概念的选定问题的问题文本和学习难度参数 （μq）。习得的难度级别符合我们对这些问题难度的直觉。</em></p>
</blockquote>
<p>表 7 列出了三个不同概念的<strong>示例问题</strong>，即“对正小数进行排序”、“单个事件的概率”和“分数到百分比的转换”，以及它们<strong>学习的难度参数</strong>。我们为每个概念展示了三个问题：一个简单的问题、一个普通的问题和一个困难的问题。以“单个事件的概率”概念为例，学习的难度参数值 （μq ） 为简单难度为 −0.0515，平均难度为 0.0088，困难难度为 0.0548。这些学习的难度级别与我们对这些问题的难度级别的理解相符。</p>
<p>这些结果表明，AKT 有可能应用于现实世界的教育环境。使用估计的难度参数，计算机化学习平台可以：</p>
<ol>
<li>根据每个学习者过去的回答自动选择具有适当难度级别的问题</li>
<li>通过向教师提供从真实数据中学到的问题难度级别的反馈来支持教师调整课程计划。</li>
</ol>
<p>因此，AKT 不仅通过提供最先进的预测性能，而且还表现出可解释性和个性化学习的潜力，从而改进了现有的 KT 方法。</p>
<h1 id="Conclusion-and-Future-Work"><a href="#Conclusion-and-Future-Work" class="headerlink" title="Conclusion and Future Work"></a>Conclusion and Future Work</h1><p>在本文中，我们提出了注意力知识追踪，这是一种完全依赖于注意力网络的知识追踪新方法。我们的方法通过<strong>（1）构建问题和回答的上下文感知表示</strong>，**(2)使用单调注意力机制在正确的时间尺度上总结过去的学习者表现<strong>，以及</strong>(3)使用 Rasch 模型来捕捉涵盖同一概念的问题之间的个体差异**，从而改进了现有的知识追踪方法。在一系列基准真实世界学习者反应数据集上的实验结果表明，我们的方法优于最先进的 KT 方法，并表现出出色的可解释性。未来工作的途径包括 ：</p>
<ul>
<li><p>合并问题文本以进一步增强问题和概念嵌入的可解释性</p>
</li>
<li><p>测试我们的方法是否可以提高发生记忆衰减的语言学习数据集的预测性能</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Chiyomi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/09/AKT-note/">http://example.com/2024/10/09/AKT-note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/readingnotes/">readingnotes</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="next-post pull-full" href="/2024/10/08/note10-8/" title="note10-8"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">note10-8</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a href="/2024/09/20/KT-notes920/" title="论文阅读笔记920"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-20</div><div class="title">论文阅读笔记920</div></div></a><a href="/2024/10/04/SAKT-notes/" title="SAKT-note"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-04</div><div class="title">SAKT-note</div></div></a><a href="/2024/09/13/KT-summarize2024/" title="KT-summarize2024"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-13</div><div class="title">KT-summarize2024</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Chiyomi</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Contributions"><span class="toc-number">2.</span> <span class="toc-text">Contributions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Problem-Setup"><span class="toc-number">3.</span> <span class="toc-text">Problem Setup</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#THE-AKT-METHOD"><span class="toc-number">4.</span> <span class="toc-text">THE AKT METHOD</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E8%A1%A8%E8%BE%BE%E5%92%8C%E7%9F%A5%E8%AF%86%E6%A3%80%E7%B4%A2%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">上下文感知表达和知识检索器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.</span> <span class="toc-text">单调注意力机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">上下文感知距离度量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%A4%B4%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%92%8C%E5%AD%90%E5%9B%BE%E5%B1%82"><span class="toc-number">4.2.2.</span> <span class="toc-text">多头注意力和子图层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E9%A2%84%E6%B5%8B"><span class="toc-number">4.3.</span> <span class="toc-text">响应预测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERasch%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B5%8C%E5%85%A5"><span class="toc-number">4.4.</span> <span class="toc-text">基于Rasch模型的嵌入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Experimental-Results"><span class="toc-number">5.</span> <span class="toc-text">Experimental Results</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Conclusion-and-Future-Work"><span class="toc-number">6.</span> <span class="toc-text">Conclusion and Future Work</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/09/AKT-note/" title="AKT-note">AKT-note</a><time datetime="2024-10-09T06:59:28.000Z" title="Created 2024-10-09 14:59:28">2024-10-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/08/note10-8/" title="note10-8">note10-8</a><time datetime="2024-10-08T06:55:50.000Z" title="Created 2024-10-08 14:55:50">2024-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/04/SAKT-notes/" title="SAKT-note">SAKT-note</a><time datetime="2024-10-04T01:17:18.000Z" title="Created 2024-10-04 09:17:18">2024-10-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/20/KT-notes920/" title="论文阅读笔记920">论文阅读笔记920</a><time datetime="2024-09-20T06:45:32.000Z" title="Created 2024-09-20 14:45:32">2024-09-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/13/KT-summarize2024/" title="KT-summarize2024">KT-summarize2024</a><time datetime="2024-09-13T12:57:31.000Z" title="Created 2024-09-13 20:57:31">2024-09-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Chiyomi</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>